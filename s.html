<!DOCTYPE html>
<html>
	<head>
		<meta charset="utf-8">
		<title>My first three.js app</title>
		<style>
			body { margin: 0; }
		</style>
	</head>
	<body>
		<script src="three.js"></script>
		<script src="./node_modules/three/examples/js/loaders/GLTFLoader.js"></script>
		<script src="./node_modules/three/examples/js/controls/OrbitControls.js"></script>
		<script type="module" src="./node_modules/three/examples/jsm/loaders/RGBELoader.js"></script>
		
		<script type="module">
								
           import { RGBELoader } from './node_modules/three/examples/jsm/loaders/RGBELoader.js';
		   var scene,renderer
		   
		   function init(){
			scene = new THREE.Scene();
			window.camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );
			camera.position.set(0, 3, 10);
			
			const ambient = new THREE.HemisphereLight(0x5588aa, 0x080820);
			scene.add(ambient);
			
			const light = new THREE.DirectionalLight(0xFFFFFF, 1);
			light.position.set( 1, 10, 7);
			scene.add(light);
			renderer = new THREE.WebGLRenderer({antialias: true});
			renderer.setSize( window.innerWidth, window.innerHeight );
			
			document.body.appendChild( renderer.domElement );
			renderer.toneMapping = THREE.ACESFilmicToneMapping
			renderer.toneMappingExposure = 4
			renderer.outputEncoding = THREE.sRGBEndcoding

			document.body.appendChild( renderer.domElement );
			
			const controls = new THREE.OrbitControls( camera, renderer.domElement );
			controls.target.set(0,4,0);
			controls.update();

			renderer.setClearColor( 0xcccccc ); 

			/* new RGBELoader().load("env2.hdr",function(texture){
				 texture.mapping = THREE.EquirectangularReflectionMapping;
				 scene.background = texture
				 scene.environment = texture
			}) */
			//renderer.render( scene, camera );
			const loader = new THREE.GLTFLoader();
            loader.load( 'titeration.glb', function ( gltf ) {
				
                scene.add( gltf.scene );
				//camera.lookAt( gltf );
				let Auditorio = gltf.scene
				Auditorio.position.y = 2;
				Auditorio.position.x = 0.5;
				camera.position.z = 10;
				//update();
				//renderer.render( scene, camera );
            }, undefined, function ( error ) {

                console.error( error );

            } );
			
			

  
window.addEventListener( 'resize', resize, false);
  
  update();
}

function update(){
  requestAnimationFrame( update );
	renderer.render( scene, camera );
}

function resize(){
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize( window.innerWidth, window.innerHeight );
}
  //raycaster

/*   const raycaster = new THREE.Raycaster();

const mouse = new THREE.Vector2();

function onMouseMove( event ) {

    // calculate mouse position in normalized device coordinates

    // (-1 to +1) for both components

    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;

    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

}
 */
/* function render() {

    // update the picking ray with the camera and mouse position

    raycaster.setFromCamera( mouse, camera );

    // calculate objects intersecting the picking ray

    const intersects = raycaster.intersectObject( scene, true );

    for ( let i = 0; i < intersects.length; i ++ ) {

        intersects[ i ].object.material.color.set( 0xff0000 );

    }

    renderer.render( scene, camera );

}

window.addEventListener( 'mousemove', onMouseMove, false );
 */
/* window.requestAnimationFrame(render);
} */


init()
			
		</script>
	</body>
</html>